
# L I B R A R I E S

import numpy as np
import math
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
from IPython import display 
from itertools import product, combinations
import matplotlib.animation as animation

#-----------------------------------------------------------------------------------------------------

# C O N S T A N T S




# General constants

# Boltzman constant
k_B = 1.4e-23
# Temperature 
T = 310
# Friction coefficient 
n_c = 1 
# Radius of latex ball 
R_b = 1e-6 
# Density of the ball
rho = 60
# Mass of the ball
m_b = rho * (4/3) * math.pi * (R_b)**3 # Mass of the latex ball
# Length of the cell to use
L = 1e-12


# Constants for random forces
# Gamma, the friction coefficient
gamma = 6 * math.pi * n_c * R_b
# Mu
mu = 0
# Sigma
sigma = 2*gamma*k_B*T




# Initial conditions

# Initial velocity in x-direction
v_x0 = 0
# Initial velocity in the y-direction
v_y0 = 0
# Initial velocity in the z-direction
v_z0 = 0
# Initial position in the x-direction
r_x0 = L/2
# Initial position in the y-direction
r_y0 = L/2
# Initial position in the z-direction
r_z0 = L/2
# The total time to run the simulation for



# For integration steps
t_total = 1000
# Time steps
dt = 0.01


#------------------------------------------------------------------------------------------------------

# D E F I N I N G  P A R T I C L E  C L A S S 

class Particle:

    # Defining the __init__ method which allows us to access these variables throught the code
    def __init__(self, mu, sigma, m_b, dt, r_x0, r_y0, r_z0, v_x0, v_y0, v_z0, t_total, gamma, L, container_conditions, R_b):
        self.m_b = m_b
        self.dt = dt
        self.r_x0 = r_x0
        self.r_y0 = r_y0
        self.r_z0 = r_z0
        self.v_x0 = v_x0
        self.v_y0 = v_y0
        self.v_z0 = v_z0
        self.t_total = t_total
        self.gamma = gamma
        self.L = L
        self.container_conditions = container_conditions
        self.mu = mu
        self.sigma = sigma
        self.R_b = R_b
    # Defining a function, random force, which will return a random force with its x-coordinate, its
    # y-coordinate and its z-coordinate
    def random_force(self):

        # The x, y and z coordinates, randomally generated by a normal distribution with mu and sigma
        random_fx = np.random.normal(self.mu, self.sigma)
        random_fy = np.random.normal(self.mu, self.sigma)
        random_fz = np.random.normal(self.mu, self.sigma)

        return random_fx, random_fy, random_fz
    
    # Defining a function which returns the total force, which is a combination of the random force and
    # the frictional force for the x-coordinate, the y-coordinate and the z-coordinate
    def total_force(self, v_x, v_y, v_z):

        # Run the random force function
        random_fx, random_fy, random_fz = self.random_force()

        # Defining the frictional force in the x, y and zdirection, which depends on v which is 
        # defined in a seperatenfunction in the class
        f_fric_x0 = -1*self.gamma*v_x
        f_fric_y0 = -1*self.gamma*v_y
        f_fric_z0 = -1*self.gamma*v_z

        # Limit the frictional force in the x, y and z direction, so they don't become too high
        if (math.copysign(1, self.v_x0 + (f_fric_x0/self.m_b)*self.dt) != math.copysign(1, self.v_x0)):
            f_fric_x0 = -1*self.m_b / self.dt * v_x
        if (math.copysign(1, self.v_y0 + (f_fric_y0/self.m_b)*self.dt) != math.copysign(1, self.v_y0)):
            f_fric_y0 = -1*self.m_b / self.dt * v_y
        if (math.copysign(1, self.v_z0 + (f_fric_z0/self.m_b)*self.dt) != math.copysign(1, self.v_z0)):
            f_fric_z0 = -1*self.m_b / self.dt * v_z

        # Total force in the x, y and z direction, the addition of the frictional force and the random force
        fx0 = f_fric_x0 + random_fx
        fy0 = f_fric_y0 + random_fy
        fz0 = f_fric_z0 + random_fz

        return fx0, fy0, fz0

    # Defining a function which will update the position of the particle by integrating the 
    # ODEs which represent the equations of motion
    def position(self):

        # List of the position in the x-direction
        r_x = []
        # List of the position in the y-direction
        r_y = []
        # List of the position in the z-direction
        r_z = []
        # List of the velocity in the x-direction
        v_x = []
        # List of the velocity in the y-direction
        v_y = []
        # List of the velocity in the z-direction
        v_z = []


        for _ in range(self.t_total):

            # Run the function which finds the total force 
            fx, fy, fz = self.total_force(self.v_x0, self.v_y0, self.v_z0)

            # Update the position in the x, y and z direction
            r_x1 = self.r_x0 +  self.v_x0 * self.dt
            r_y1 = self.r_y0  + self.v_y0 * self.dt
            r_z1 = self.r_z0 + self.v_z0 * self.dt
            
            # Ensure that the position of the particle is contained to within the box by calling another class
            # which is defined below, and a specific method from the class called particle boundary
            r_x1, r_y1, r_z1 = container_conditions.particle_boundary(r_x1, r_y1, r_z1)

            # TODO: should check that this doesn't flip the sign eg. friction reduces to 0 not -100 etc
            # Update the velocity in the x, y and z direction
            v_x1 = self.v_x0 + (fx/self.m_b)*self.dt
            v_y1 = self.v_y0 + (fy/self.m_b)*self.dt
            v_z1 = self.v_z0 + (fz/self.m_b)*self.dt

            # If the particle touches the boundary, the velocity will change according to the reflection
            # condition which is defined in a class below, and in a specific method called reflection condition
            v_x1, v_y1, v_z1 = container_conditions.reflection_condition(r_x1, r_y1, r_z1, v_x1, v_y1, v_z1)

            # Append the new position x-coordinate to the list
            r_x.append(r_x1)
            # Append the new position y-coordinate to the list
            r_y.append(r_y1)
            # Append the new position z-coordinate to the list
            r_z.append(r_z1)

            # Append the new velocity x-coordinate to the list
            v_x.append(v_x1)
            # Append the new velocity y-coordinate to the list
            v_y.append(v_y1)
            # Append the new velocity z-coordinate to the list
            v_z.append(v_z1)

            # Set the current position x-coordinate to its updated value
            self.r_x0 = r_x1
            # Set the current position y-coordinate to its updated value
            self.r_y0 = r_y1
            # Set the current position z-coordinate to its updated value
            self.r_z0 = r_z1

            # Set the current velocity x-coordinate to its updated value
            self.v_x0 = v_x1
            # Set the current velocity y-coordinate to its updated value
            self.v_y0 = v_y1
            # Set the current velocity z-coordinate to its updated value
            self.v_z0 = v_z1

        return r_x, r_y, r_z, v_x, v_y, v_z
    
#--------------------------------------------------------------------------------------------------------

# D E F I N I N G  C O N T A I N E R  C O N D I T I O N S
class Container_Conditions:

    # Defining the __init__ method which will allow us to access the L variable throughout
    def __init__(self, L, R_b):
        self.L = L
        self.R_b = R_b
    # Defining particle boundary which ensures the particle cannot go beyond the box boundary
    def particle_boundary(self, x, y, z):

        # Ensures that the x y and z coordinate of the particle position cannot go beyond box boundary 
        clipped_x = np.clip(x, 0, self.L)
        clipped_y = np.clip(y, 0, self.L)
        clipped_z = np.clip(z, 0, self.L)

        return clipped_x, clipped_y, clipped_z

    # Defining reflection condition which modifies the velocity of the particle if it touches the boundary
    def reflection_condition(self, x, y, z, v_x, v_y, v_z):

        # If the x, y or z coordinate of the particle tries to go beyond boundary, multiply its velocity by -1
        if (x  <= 0) or (x >= self.L ):
           v_x = -1*v_x
        if (y  <= 0) or (y >= self.L ):
            v_y = -1*v_y
        if (z <= 0) or (z >= self.L ):
            v_z = -1*v_z
        
        return v_x, v_y, v_z

#---------------------------------------------------------------------------------------------------------

# R U N  F U N C T I O N S

# Call container_conditions the consequence of running the class Container_Conditions with L as input
container_conditions = Container_Conditions(L, R_b)

# Call particle the consequence of running the class Particle with its various inputs
particle = Particle(mu, sigma, m_b, dt, r_x0, r_y0, r_z0, v_x0, v_y0, v_z0, t_total, gamma, L, container_conditions, R_b)

# Call run the consequence of running particle with respect to the method position
run = particle.position()


#--------------------------------------------------------------------------------------------------------

# N O R M  A N D  I S O T R O P I C  C H E C K
no_of_runs = 1000

# Define a function which calculates the average norm when we calculate the random force in the x, y and z direction 
# Its input is no_of_runs, which is defined along with the constants
def norm_isotropic_check(no_of_runs):

    # A list of the norms from each generation of the random forces
    norm_list = []

    # Initialise count to determine if the random force in the x-direction is negative
    negative_x = 0
    # Initialise count to determine if the random force in the y-direction is negative
    negative_y = 0
    # Initialise count to determine if the random force in the z-direction is negative
    negative_z = 0

    # Initialise count to determine if the random force in the x-direction is positive
    positive_x = 0
    # Initialise count to determine if the random force in the y-direction is positive
    positive_y = 0
    # Initialise count to determine if the random force in the z-direction is positive
    positive_z = 0

    for _ in range(no_of_runs):

        # The x, y and z coordinate for the random force, where we call the random force defined in particle class
        f_x, f_y, f_z = particle.random_force()

        # Calculate norm by standard formula
        norm = math.sqrt((f_x)**2 + (f_y)**2 + (f_z)**2)
        # Append the norm to the list
        norm_list.append(norm)

        # If the force in the x-direction is less than 0 then increase the negative_x counter by 1 and if not then increase the positive_x counter by 1
        if f_x <0:
            negative_x += 1
        else:
            positive_x +=1

        # If the force in the y-direction is less than 0 then increase the negative_y counter by 1 and if not then increase the positive_y counter by 1
        if f_y <0:
            negative_y +=1
        else:
            positive_y +=1

        # If the force in the z-direction is less than 0 then increase the negative_z counter by 1 and if not then increase the positive_z counter by 1
        if f_z <0:
            negative_z +=1
        else:
            positive_z +=1

    norm_average = np.average(norm_list) 
    # Print a statement about the average norm
    print(f"The norm average across {no_of_runs} generations of random forces  is: {norm_average}, which is so small that it is essentially 0.")

    # Print a series of statements about the number of forces in the x, y and z direction to show the force is isotropic
    print(f"In the x-direction, across {no_of_runs} runs of the random force function, there are {negative_x} in the negative direction and {positive_x} in the positive direction.")
    print(f"In the y-direction, across {no_of_runs} runs of the random force function, there are {negative_y} in the negative direction and {positive_y} in the positive direction.") 
    print(f"In the z-direction, across {no_of_runs} runs of the random force function, there are {negative_z} in the negative direction and {positive_z} in the positive direction.")
    print("One thus concludes that the norm of the force is 0 on average and that the force is isotopic (as generally same number of forces in positive direction and in the negative direction).")

norm_isotropic_check(no_of_runs)
#---------------------------------------------------------------------------------------------------------

# 3 D  P L O T  O F  P O I N T S

# Plot the 3D axes
ax = plt.axes(projection ="3d")
ax.set_xlim(0, L) 
ax.set_ylim(0,L)
ax.set_zlim(0,L)

# Feed the position x-coordintes, y-coordinates and z-coordinates from running functions into the plot
ax.scatter3D(run[0], run[1], run[2], color = "blue")

# Plot the title
plt.title("Position of Point Particle Contained in a Box")
# Show the plot
plt.show()

#-------------------------------------------------------------------------------------------------------

# A N I M A T I O N 

# Initialise X, Y and Z list
X = []
Y = []
Z = []

# Define a function called update with input t as time, which will update the position to animate plot
def update(t):

    # Clear the axes
    axis.cla()

    # Call x, y and z their respective run vectors and run through the list each time step 
    x = run[0][t]
    y = run[1][t]
    z = run[2][t]

    # Append x, y and z to X, Y and Z to plot
    X.append(x)
    Y.append(y)
    Z.append(z)

    # Produce the scatter for x, y and z 
    axis.scatter(x, y, z, s=100, marker = 'o')

    # Plot X, Y and Z too
    axis.plot(X, Y, Z)

    # Plot the x, y and z axis from 0 to L
    axis.set_xlim((0, L))
    axis.set_ylim((0, L))
    axis.set_zlim((0, L))


# Plot figure
fig = plt.figure(dpi=100)

# Make it a 3D plot
axis = fig.add_subplot(projection='3d')

# Make the plot animated by running the animate function
ani = animation.FuncAnimation(fig = fig, func = update, frames = t_total, interval = 100, repeat = False)


fig.suptitle('Point Particle in Box, 10000 Runs')

#FFwriter = animation.FFMpegWriter(fps = 10)

# To save the animation using Pillow as a gif
#ani.save('Point_Particle_5000_Runs.mp4', writer= FFwriter)

# Show plot
plt.show()







