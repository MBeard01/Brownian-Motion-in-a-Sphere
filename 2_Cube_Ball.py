
# L I B R A R I E S

import numpy as np
import math
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
from IPython import display 
from itertools import product, combinations
import matplotlib.animation as animation

#-----------------------------------------------------------------------------------------------------

# C O N S T A N T S

# Constants needed for model

# Boltzman constant
k_B = 1.4e-23
# Temperature 
T = 310
# Friction coefficient - is there a scaling or unit error here, cause if 1 it doesn't run
n_c = 100000000
# Minimum possible length of cube (cell)
L_min_cell = 10e-6 
# Maximum possible length of cube (cell)
L_max_cell = 100e-6 
# Radius of latex ball 
R_b = 1e-6 
# Density of the ball
rho = 60
# Mass of the ball
m_b = rho * (4/3) * math.pi * (R_b)**3 
# Gamma, the friction coefficient
gamma = 6 * math.pi * n_c * R_b 
# Mu
mu = 0
# Sigma
sigma = 2*gamma*k_B*T
# Length of the cell to use
L = L_max_cell



# Initial velocity

# Initial velocity in x-direction
v_x0 = 0
# Initial velocity in the y-direction
v_y0 = 0
# Initial velocity in the z-direction
v_z0 = 0



# Intiial position

# Initial position in the x-direction
r_x0 = L/2
# Initial position in the y-direction
r_y0 = L/2
# Initial position in the z-direction
r_z0 = L/2
# The total time to run the simulation for



# Integration information

t_total = 1000
# Time steps
dt = 0.01



# Testing normal forces

# Number of iterations to test random force with
its_f_random = 100


#------------------------------------------------------------------------------------------------------

# D E F I N I N G  P A R T I C L E  C L A S S 

class Particle:

    # Defining the __init__ method which allows us to access these variables throught the code
    def __init__(self, mu, sigma, m_b, dt, r_x0, r_y0, r_z0, v_x0, v_y0, v_z0, t_total, gamma, L, container_conditions, R_b):
        self.m_b = m_b
        self.dt = dt
        self.r_x0 = r_x0
        self.r_y0 = r_y0
        self.r_z0 = r_z0
        self.v_x0 = v_x0
        self.v_y0 = v_y0
        self.v_z0 = v_z0
        self.t_total = t_total
        self.gamma = gamma
        self.L = L
        self.container_conditions = container_conditions
        self.mu = mu
        self.sigma = sigma
        self.R_b = R_b

    # Defining a function, random force, which will return a random force with its x-coordinate, its
    # y-coordinate and its z-coordinate
    def random_force(self):

        # The x, y and z coordinates, randomally generated by a normal distribution with mu and sigma
        random_fx = np.random.normal(self.mu, self.sigma)
        random_fy = np.random.normal(self.mu, self.sigma)
        random_fz = np.random.normal(self.mu, self.sigma)

        return random_fx, random_fy, random_fz
    
    # Defining a function which returns the total force, which is a combination of the random force and
    # the frictional force for the x-coordinate, the y-coordinate and the z-coordinate
    def total_force(self, v_x, v_y, v_z):

        # Run the random force function
        random_fx, random_fy, random_fz = self.random_force()

        # Defining the frictional force in the x, y and zdirection, which depends on v which is 
        # defined in a seperatenfunction in the class
        f_fric_x0 = -1*self.gamma*v_x
        f_fric_y0 = -1*self.gamma*v_y
        f_fric_z0 = -1*self.gamma*v_z

        # Limit the frictional force in the x, y and z direction, so they don't become too high
        # It will set the friction to be much smaller, namely -mass/dt*v if it vecomes too large or it will limit 
        # movement of the ball so much that it can't move
        if (math.copysign(1, self.v_x0 + (f_fric_x0/self.m_b)*self.dt) != math.copysign(1, self.v_x0)):
            f_fric_x0 = -1*self.m_b / self.dt * v_x
        if (math.copysign(1, self.v_y0 + (f_fric_y0/self.m_b)*self.dt) != math.copysign(1, self.v_y0)):
            f_fric_y0 = -1*self.m_b / self.dt * v_y
        if (math.copysign(1, self.v_z0 + (f_fric_z0/self.m_b)*self.dt) != math.copysign(1, self.v_z0)):
            f_fric_z0 = -1*self.m_b / self.dt * v_z

        # Total force in the x, y and z direction, the addition of the frictional force and the random force
        fx0 = f_fric_x0 + random_fx
        fy0 = f_fric_y0 + random_fy
        fz0 = f_fric_z0 + random_fz

        return fx0, fy0, fz0

    # Defining a function which will update the position of the particle by integrating the 
    # ODEs which represent the equations of motion
    def position(self):

        # List of the positions
        r_x = []
        r_y = []
        r_z = []

        # List of the velocities
        v_x = []
        v_y = []
        v_z = []

        #Â Now solve the equations of motion across the specified time steps with dt which is already defined
        for _ in range(self.t_total):

            # Run the function which finds the total force, this will run each time step
            fx, fy, fz = self.total_force(self.v_x0, self.v_y0, self.v_z0)

            # Update the position in the x, y and z direction
            r_x1 = self.r_x0 +  self.v_x0 * self.dt
            r_y1 = self.r_y0 + self.v_y0 * self.dt
            r_z1 = self.r_z0 + self.v_z0 * self.dt
            
            # Ensure that the position of the particle is contained to within the box by calling another class
            # which is defined below, and a specific method from the class called particle boundary
            r_x1, r_y1, r_z1 = container_conditions.particle_boundary(r_x1, r_y1, r_z1)

            # Update the velocity in the x, y and z direction
            v_x1 = self.v_x0 + (fx/self.m_b)*self.dt
            v_y1 = self.v_y0 + (fy/self.m_b)*self.dt
            v_z1 = self.v_z0 + (fz/self.m_b)*self.dt

            # If the particle touches the boundary, the velocity will change according to the reflection
            # condition which is defined in a class below, and in a specific method called reflection condition
            v_x1, v_y1, v_z1 = container_conditions.reflection_condition(r_x1, r_y1, r_z1, v_x1, v_y1, v_z1)

            # Append the new positions
            r_x.append(r_x1)
            r_y.append(r_y1)
            r_z.append(r_z1)

            # Append the new velocities
            v_x.append(v_x1)
            v_y.append(v_y1)
            v_z.append(v_z1)

            # Set the current position to its updated value
            self.r_x0 = r_x1
            self.r_y0 = r_y1
            self.r_z0 = r_z1

            # Set the current velocity to its updated value
            self.v_x0 = v_x1
            self.v_y0 = v_y1
            self.v_z0 = v_z1

        return r_x, r_y, r_z, v_x, v_y, v_z
    
#--------------------------------------------------------------------------------------------------------

# D E F I N I N G  C O N T A I N E R  C O N D I T I O N S
class Container_Conditions:

    # Defining the __init__ method which will allow us to access the L variable throughout
    def __init__(self, L, R_b):
        self.L = L
        self.R_b = R_b

    # Defining particle boundary which ensures the particle cannot go beyond the box boundary
    def particle_boundary(self, x, y, z):

        # Ensures that the x y and z coordinate of the particle position cannot go beyond box boundary 
        # Unlike the point particle, the ball when we account for its radius can't go below its radius, or half of it would be out of the box
        # and it can't be greater than the height or width of the box subtract the radius for the same logic
        clipped_x = np.clip(x, self.R_b, self.L - self.R_b)
        clipped_y = np.clip(y, self.R_b, self.L - self.R_b)
        clipped_z = np.clip(z, self.R_b, self.L - self.R_b)

        return clipped_x, clipped_y, clipped_z

      
    
    # Defining reflection condition which modifies the velocity of the particle if it touches the boundary
    def reflection_condition(self, x, y, z, v_x, v_y, v_z):

        # If the x, y or z coordinate of the particle tries to go beyond boundary, multiply its velocity by -1
        # Again, this is a similar principle to the point particle but now we have added a sense of the radius of the ball
        if (x  <= self.R_b) or (x >= self.L - self.R_b):
           v_x = -1*v_x
        if (y  <= self.R_b) or (y >= self.L - self.R_b):
            v_y = -1*v_y
        if (z <= self.R_b) or (z >= self.L - self.R_b):
            v_z = -1*v_z
        
        return v_x, v_y, v_z

#---------------------------------------------------------------------------------------------------------

# R U N  F U N C T I O N S

# Call container_conditions the consequence of running the class Container_Conditions with L as input
container_conditions = Container_Conditions(L, R_b)

# Call particle the consequence of running the class Particle with its various inputs
particle = Particle(mu, sigma, m_b, dt, r_x0, r_y0, r_z0, v_x0, v_y0, v_z0, t_total, gamma, L, container_conditions, R_b)

# Call run the consequence of running particle with respect to the method position
run = particle.position()

#---------------------------------------------------------------------------------------------------------

# 3 D  P L O T  O F  P O I N T S

# Plot the 3D axes
ax = plt.axes(projection ="3d")
ax.set_xlim(0, L) 
ax.set_ylim(0,L)
ax.set_zlim(0,L)

# Feed the position x-coordintes, y-coordinates and z-coordinates from running functions into the plot
ax.scatter3D(run[0], run[1], run[2], color = "blue")

# Plot the title
plt.title("Position of Ball Contained in a Box ")

# Show the plot
plt.show()

#-------------------------------------------------------------------------------------------------------

# A N I M A T I O N 

# Initialise X, Y and Z list
X = []
Y = []
Z = []

# Define a function called update with input t as time, which will update the position to animate plot
def update(t):

    # Clear the axes
    axis.cla()

    # Call x, y and z their respective run vectors and run through the list each time step 
    x = run[0][t]
    y = run[1][t]
    z = run[2][t]

    # Append x, y and z to X, Y and Z to plot
    X.append(x)
    Y.append(y)
    Z.append(z)

    # Produce the scatter for x, y and z 
    axis.scatter(x, y, z, s=100, marker = 'o')

    # Plot X, Y and Z too
    axis.plot(X, Y, Z)

    # Plot the x, y and z axis from 0 to L
    axis.set_xlim(0, L)
    axis.set_ylim(0, L)
    axis.set_zlim(0, L)


# Plot figure
fig = plt.figure(dpi=100)

# Make it a 3D plot
axis = fig.add_subplot(projection='3d')

# Make the plot animated by running the animate function
ani = animation.FuncAnimation(fig = fig, func = update, frames = t_total, interval = 100, repeat = False)

fig.suptitle('Ball in a Box, 1000 Runs')

#FFwriter = animation.FFMpegWriter(fps = 10)

# To save the animation using Pillow as a gif
#ani.save('Ball_5000_Runs.mp4', writer= FFwriter)

# Show plot
plt.show()


